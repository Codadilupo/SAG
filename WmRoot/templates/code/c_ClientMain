/*
 * %value svcName%.c:  Client for "%value literalFullSvcName%".
 *
 * This class has been automatically generated by the Software AG
 * Designer. It is recommended that you back up your changes before
 * generating new code.
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include "wmJNIc.h"

/*
 * Document API for "%value literalFullSvcName%".
 *
 *  The following table lays out the names and types (named DOCUMENT or STRING)
 *  of each document and field used by this service's input and output. The
 *  table is followed by a series of name declarations that must be used to
 *  access (set or get) the field values.
 *
 *  Names are constructed from the DOCUMENT name and the VARIABLE name within
 *  the document.  E.g., 'Order_shipTo' for DOCUMENT 'Order' and VARIABLE
 *  'shipTo'.
 *
 *  Note that fields within arrays and tables are unnamed as they are
 *  accessed by index or indices (indicated by '[]' below).
 *
%loop records%
    %value name%:  DOCUMENT {
%loop fields%%switch fieldType%
%case str%      String %value name%,
%case strarray%     String[] %value name%,
%case strtable%        String[][] %value name%,
%case rec%        %value bindToRec% %value name%,
%case recarray%        %value bindToRec%[] %value name%,
%end%%endloop%
    }%endloop%

 *
 */
%loop records%%loop fields%
static WmName %value ../name%_%value name%=0;
%endloop%%endloop%

/* Forward Declarations */
%loop records%void print_%value name%(WmRecord *rec, int pad);%endloop%

/*
 * Setup generated document/field names:
 *  Add calls to initialize your custom fields (defined above) here.
 */
int initKeys(WmCContext *cc)
{
%loop records%%loop fields%
    if ((%value ../name%_%value name% = makeWmName(cc, "%value literalName%")) == 0) return 0;
%endloop%%endloop%
    return 1;
}



/*
 * Release generated document/field names:
 *  Add calls to free your custom fields (defined above) here.
 */
void freeKeys(WmCContext *cc)
{
%loop records%%loop fields%
    freeWmName(cc, %value ../name%_%value name%);
%endloop%%endloop%
}

/* Utility for formatted output */
void indentOutput(int pad)
{
    int i;
    for (i=0; i<pad; i++)
        fprintf(stderr,"\t");
}

%loop records%
void print_%value name%(WmRecord *rec, int pad)
{
    int i,j;
    jsize x,y;
    char *tmpStr;
    WmRecord *tmpRec,*tmpRec1;

    indentOutput(pad);
    fprintf(stderr,"Document '%value name%' =>\n");
%loop fields%%switch fieldType%
%case str%
    tmpStr = getWmString(rec, %value ../name%_%value name%);
    indentOutput(pad);
    fprintf(stderr,"  String '%value literalName%' = %s\n", tmpStr);
    freeWmString(&tmpStr);
%case strarray%
    tmpRec = getWmStringArray(rec, %value ../name%_%value name%);
    x = getWmArraySize(tmpRec);
    indentOutput(pad);
    fprintf(stderr, "  StringArray '%value literalName%' len = %d\n", x);
    for (i = 0; i < x; i++) {
        tmpStr = getWmStringByIdx(tmpRec, i);
        indentOutput(pad+1);
        fprintf(stderr, "  %value literalName%[%d] = %s\n",i,tmpStr);
        freeWmString(&tmpStr);
    }
    freeWmRec(&tmpRec);
%case strtable%
    tmpRec = getWmStringTable(rec, %value ../name%_%value name%);
    getWmTableSize(tmpRec, &x, &y);
    indentOutput(pad);
    fprintf(stderr, "  StringTable '%value literalName%' size = [%d,%d]\n",x,y);
    for (i = 0; i < x; i++) {
        for (j = 0; j < y; j++) {
            tmpStr = getWmStringByIndices(tmpRec,i,j);
            indentOutput(pad+1);
            fprintf(stderr, "  %value literalName%[%d,%d] = %s\n",i,j,tmpStr);
            freeWmString(&tmpStr);
        }
    }
    freeWmRec(&tmpRec);
%case rec%
    tmpRec = getWmRec(rec, %value ../name%_%value name%);
    indentOutput(pad);
    fprintf(stderr, "  Nested Document '%value literalName%' = \n");
    print_%value bindToRec%(tmpRec, pad+1);
    freeWmRec(&tmpRec);
%case recarray%
    tmpRec = getWmRecArray(rec, %value ../name%_%value name%);
    x = getWmArraySize(tmpRec);
    indentOutput(pad);
    fprintf(stderr,"  DocumentArray '%value literalName%' len = %d \n", x);
    for (i = 0; i < x; i++) {
        tmpRec1 = getWmRecByIdx(tmpRec, i);
        indentOutput(pad);
        fprintf(stderr,"  %value literalName%[%d] = \n", i);
        print_%value bindToRec%(tmpRec1, pad+1);
        freeWmRec(&tmpRec1);
    }
    freeWmRec(&tmpRec);
%end%%endloop%
}
%endloop%

/**** Service Invocation Function ****/
int invokeSvc(WmCContext *cc)
{
    int result = 0;
    WmRecord *in, *out;
    char     buf[80];

    /* [Declare inputs] */
%loop inputRec%
%loop fields%%switch fieldType%
%case str%
%case%
    WmRecord    *i_%value name%=NULL;
%end%%endloop%%endloop%

    /* [setup keys for input and output documents] */
    if (!initKeys(cc)) return -1;

    if ((in = newWmRec(cc)) == 0) goto error;

%ifvar inputRec%
    fprintf(stderr, "\n ** Please enter the required Input parameters **\n\n");
%else%
    fprintf(stderr, "\n This service does not require any inputs.\n\n");
%endif%
    /* [set inputs] */
%loop inputRec%
%loop fields%%switch fieldType%
%case str%
    fprintf(stderr, "%s = ", "%value literalName%");
    scanf("%s", buf);
    if (!setWmString(in, %value ../name%_%value name%, buf)) goto error;
%case strarray%
    fprintf(stderr, "%s = ", "%value literalName%");
    scanf("%s", buf);
    i_%value name% = newWmStringArray(cc, 1);
    if (!setWmStringByIdx(i_%value name%, 0, buf)) goto error;
    if (!setWmStringArray(in, %value ../name%_%value name%, i_%value name%)) goto error;
%case strtable%
    fprintf(stderr, "%s = ", "%value literalName%");
    scanf("%s", buf);
    i_%value name% = newWmStringTable(cc, 1, 1);
    if (!setWmStringByIndices(i_%value name%, 0, 0, buf)) goto error;
    if (!setWmStringTable(in, %value ../name%_%value name%, i_%value name%)) goto error;
%case rec%
    i_%value name% = newWmRec(cc);
    if (!setWmRec(in, %value ../name%_%value name%, i_%value name%)) goto error;
%case recarray%
    i_%value name% = newWmRecArray(cc, 1);
    if (!setWmRecArray(in, %value ../name%_%value name%, i_%value name%)) goto error;
%end%%endloop%%endloop%

    /* [Invoke Service] */
    out = invokeWmSync(cc, "%value literalIfcName%", "%value svcName%", in);
    if (out == 0) goto error;
    fprintf(stderr,"\n ********* Successful invoke **********\n");

%ifvar outputRec%
    /* [access outputs and print] */
    fprintf(stderr,"\n ************* OUTPUTS ****************\n\n");
    print_%value outputRecName%(out,0);
%else%
    fprintf(stderr, "\n This service does not return any outputs.\n\n");
%endif%
    goto cleanup;

error:
    result = -1;

cleanup:
%loop inputRec%
%loop fields%%switch fieldType%
%case str%
%case%
    freeWmRec(&i_%value name%);
%end%%endloop%%endloop%
    freeWmRec(&in);
    freeWmRec(&out);
    freeKeys(cc);

    return 0;
}

int main(int argc, char **argv)
{
    char        *host = "%value serverHost%";
    char        *port = "%value serverPort%";
    char        *server = "%value serverHostPort%";
    char        *user = "";
    char        *password = "";

    WmCContext  *cc = NULL;

    int         result = 0;

    /* ---- Select host and port --- */
    if (argc > 4) {
        user = argv[3];
        password = argv[4];
    }
    if (argc > 2) port = argv[2];
    if (argc > 1) {
        host = argv[1];
        strcat(strcpy(server, host),port);
    }

    if (!initWmClient())
        return -1;

    cc = newWmClientContext();
    if (cc == 0)
        return -1;

    /* --- Connect to server --- */
    if (!connectCcUserPass(cc, server, user, password))
        return -1;

    /* Uncomment and set values if you need to go through a Proxy Server */
    /* if (!setCcProxy(cc,<proxy host>,<proxy port>,<user>,<password>))
        return -1;*/

    /* --- Invoke Service --- */
    result = invokeSvc(cc);

    /* --- Cleanup --- */
    disconnectCc(cc);
    freeWmContext(&cc);
    shutdownWmClient();

    return result;
}

